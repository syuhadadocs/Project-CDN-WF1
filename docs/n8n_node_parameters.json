{
  "CDN WF1 - Inbound Orchestrator v3 (Hybrid)": [
    {
      "name": "Webhook Inbound Unified v3",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "parameters": {
        "httpMethod": "POST",
        "path": "cdn-wf1-unified-v3",
        "responseMode": "onReceived",
        "responseCode": 202,
        "responseData": "={{ { ok: true, accepted: true } }}",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Normalize Inbound",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "// Normalize multi-channel inbound payload into internal schema.\n// Expect req body in $json (from Webhook).\nconst body = $json.body ?? $json;\n// --- Provider detection (edit as needed) ---\nlet provider = body.provider || \"WAHA\";\nlet channel  = body.channel  || \"whatsapp\";\n\n// Thread id normalization (prioritize WAHA fields if present)\nconst thread_id = body.thread_id\n  || body.remoteJidAlt\n  || body.remoteJid\n  || body.from\n  || body.chatId\n  || body.email_thread_id\n  || \"\";\n\nconst content = body.content\n  || body.text\n  || body.message\n  || (body.data && body.data.text)\n  || \"\";\n\nconst provider_message_id = body.provider_message_id\n  || (body.key && body.key.id)\n  || body.messageId\n  || body.id\n  || \"\";\n\nconst provider_event_id = body.provider_event_id\n  || body.eventId\n  || body.event_id\n  || \"\";\n\nconst sent_at = body.sent_at\n  || (body.messageTimestamp ? new Date(Number(body.messageTimestamp)*1000).toISOString() : null)\n  || new Date().toISOString();\n\nconst trace_id = body.trace_id || $execution.id || (\"TRC-\" + Date.now());\n\n// Minimal schema output\nreturn [{\n  json: {\n    provider, channel, thread_id,\n    provider_message_id, provider_event_id,\n    sent_at,\n    sender: \"user\",\n    content,\n    raw_json: JSON.stringify(body),\n    trace_id\n  }\n}];\n"
      },
      "notes": ""
    },
    {
      "name": "IF - Schema Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.thread_id}}",
              "operation": "isNotEmpty"
            },
            {
              "value1": "={{$json.content}}",
              "operation": "isNotEmpty"
            },
            {
              "value1": "={{$json.provider_message_id}}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "Code - Build Dedupe Key",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "return [{json:{...$json, dedupe_key:`in|${$json.provider}|${$json.provider_message_id}`}}];"
      },
      "notes": ""
    },
    {
      "name": "GS - Lookup Idempotency (dedupe_key)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "lookup",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "idempotency_keys",
        "lookupColumn": "idem_key",
        "lookupValue": "={{$json.dedupe_key}}",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "IF - Already Processed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.idem_key !== undefined && ($json.status === 'DONE' || $json.status === 'IN_PROGRESS')}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Upsert Idempotency IN_PROGRESS",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "append",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "idempotency_keys",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "idem_key": "={{$json.dedupe_key}}",
            "scope": "inbound",
            "ref_type": "message",
            "ref_id": "",
            "status": "IN_PROGRESS",
            "created_at": "={{new Date().toISOString()}}",
            "expires_at": "={{new Date(Date.now()+2*24*3600*1000).toISOString()}}",
            "last_seen_at": "={{new Date().toISOString()}}",
            "result_json": "",
            "error_message": ""
          }
        },
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "GS - Lookup Thread Lock",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "lookup",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "thread_locks",
        "lookupColumn": "thread_id",
        "lookupValue": "={{$json.thread_id}}",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Decide Lock Acquire",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "const lock = $json; // row from lookup or empty item\nconst now = Date.now();\nconst lockedUntil = lock.locked_until ? Date.parse(lock.locked_until) : 0;\nconst acquire = !lock.thread_id || isNaN(lockedUntil) || lockedUntil < now;\nreturn [{json:{...$json, lock_acquire: acquire, now_iso: new Date().toISOString()}}];\n"
      },
      "notes": ""
    },
    {
      "name": "IF - Lock Acquired?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.lock_acquire}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Upsert Thread Lock (Acquire)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "appendOrUpdate",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "thread_locks",
        "keyColumn": "thread_id",
        "keyValue": "={{$json.thread_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "thread_id": "={{$json.thread_id}}",
            "active_ticket_id": "={{$json.active_ticket_id || ''}}",
            "lock_owner": "={{$execution.id}}",
            "locked_until": "={{new Date(Date.now() + (Number($env.THREAD_LOCK_SECONDS || 30)*1000)).toISOString()}}",
            "last_inbound_message_id": "={{$json.provider_message_id}}",
            "last_inbound_at": "={{$json.sent_at}}",
            "last_ticket_status": "",
            "last_seen_at": "={{new Date().toISOString()}}",
            "created_at": "={{$json.created_at || new Date().toISOString()}}",
            "updated_at": "={{new Date().toISOString()}}",
            "notes": ""
          }
        },
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "GS - Lookup Customer (default_thread_id)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "lookup",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "customers",
        "lookupColumn": "default_thread_id",
        "lookupValue": "={{$json.thread_id}}",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Resolve Customer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "// Create deterministic-ish customer_id if missing (simple hash).\nfunction djb2(str){ let h=5381; for (let i=0;i<str.length;i++) h=((h<<5)+h)+str.charCodeAt(i); return h>>>0; }\nconst existingId = $json.customer_id;\nconst thread = $json.thread_id || \"\";\nconst suffix = (djb2(thread) % 1000000).toString().padStart(6,'0');\nconst today = new Date().toISOString().slice(0,10).replaceAll('-','');\nconst customer_id = existingId || `CUS${today}${suffix}`;\nreturn [{\n  json: {\n    ...$json,\n    customer_id,\n    updated_at: new Date().toISOString(),\n    last_seen_at: new Date().toISOString(),\n    default_thread_id: thread,\n    default_channel: $json.channel\n  }\n}];\n"
      },
      "notes": ""
    },
    {
      "name": "GS - Upsert Customer",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "appendOrUpdate",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "customers",
        "keyColumn": "customer_id",
        "keyValue": "={{$json.customer_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "customer_id": "={{$json.customer_id}}",
            "created_at": "={{$json.created_at || new Date().toISOString()}}",
            "updated_at": "={{$json.updated_at}}",
            "status": "active",
            "name": "={{$json.name || ''}}",
            "phone": "={{$json.phone || ''}}",
            "email": "={{$json.email || ''}}",
            "telegram_username": "={{$json.telegram_username || ''}}",
            "default_channel": "={{$json.default_channel}}",
            "default_thread_id": "={{$json.default_thread_id}}",
            "notes": "={{$json.notes || ''}}",
            "profile_json": "={{$json.profile_json || ''}}",
            "preferences_json": "={{$json.preferences_json || ''}}",
            "active_ticket_id": "={{$json.active_ticket_id || ''}}",
            "last_intent": "={{$json.last_intent || ''}}",
            "last_seen_at": "={{$json.last_seen_at}}"
          }
        },
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "GS - Read Tickets by thread_id",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "read",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "tickets",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Resolve Ticket (reuse/reopen)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "// NOTE: Google Sheets read returns many rows; filter in code.\nconst all = items.map(i => i.json); // if connected correctly, this node should receive list of tickets rows\nconst thread_id = $json.thread_id;\nconst reuseHours = Number($env.TICKET_REUSE_WINDOW_HOURS || 24);\nconst now = Date.now();\n\nconst related = all.filter(t => t.thread_id === thread_id);\nconst isOpen = (s) => !['closed','resolved','selesai'].includes(String(s||'').toLowerCase());\nlet active = related.filter(t => isOpen(t.status));\nactive.sort((a,b)=> Date.parse(b.updated_at||b.created_at||0) - Date.parse(a.updated_at||a.created_at||0));\n\nlet chosen = active[0];\nif (!chosen && related.length){\n  related.sort((a,b)=> Date.parse(b.updated_at||b.created_at||0) - Date.parse(a.updated_at||a.created_at||0));\n  const last = related[0];\n  const ageH = (now - Date.parse(last.updated_at||last.created_at||now))/3600000;\n  if (ageH <= reuseHours){\n    chosen = {...last, status: 'open', reopened_at: new Date().toISOString()};\n  }\n}\nif (!chosen){\n  const today = new Date().toISOString().slice(0,10).replaceAll('-','');\n  const suffix = String(Math.floor(Math.random()*1e6)).padStart(6,'0');\n  chosen = {\n    ticket_id: `TCK${today}${suffix}`,\n    created_at: new Date().toISOString(),\n    status: 'open',\n    stage: 'chat',\n    priority: 'normal',\n    tags: '',\n    meta_json: ''\n  };\n}\nchosen.updated_at = new Date().toISOString();\nchosen.thread_id = thread_id;\nchosen.channel = $json.channel;\nchosen.customer_ref = $json.customer_id;\nchosen.last_inbound_at = $json.sent_at;\nchosen.last_message_snippet = ($json.content||'').slice(0,200);\nchosen.unread_flag = 'TRUE';\nreturn [{json:{...$json, ticket: chosen, ticket_id: chosen.ticket_id, active_ticket_id: chosen.ticket_id}}];\n"
      },
      "notes": ""
    },
    {
      "name": "GS - Upsert Ticket",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "appendOrUpdate",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "tickets",
        "keyColumn": "ticket_id",
        "keyValue": "={{$json.ticket_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "ticket_id": "={{$json.ticket.ticket_id}}",
            "created_at": "={{$json.ticket.created_at || new Date().toISOString()}}",
            "updated_at": "={{$json.ticket.updated_at}}",
            "status": "={{$json.ticket.status}}",
            "priority": "={{$json.ticket.priority || 'normal'}}",
            "channel": "={{$json.channel}}",
            "customer_ref": "={{$json.customer_id}}",
            "thread_id": "={{$json.thread_id}}",
            "last_inbound_at": "={{$json.ticket.last_inbound_at}}",
            "last_message_snippet": "={{$json.ticket.last_message_snippet}}",
            "unread_flag": "TRUE",
            "tags": "={{$json.ticket.tags || ''}}",
            "meta_json": "={{$json.ticket.meta_json || ''}}",
            "conversation_summary": "={{$json.ticket.conversation_summary || ''}}",
            "facts_json": "={{$json.ticket.facts_json || ''}}",
            "stage": "={{$json.ticket.stage || 'chat'}}",
            "handoff_flag": "={{$json.ticket.handoff_flag || 'FALSE'}}",
            "handoff_reason": "={{$json.ticket.handoff_reason || ''}}",
            "reopened_at": "={{$json.ticket.reopened_at || ''}}",
            "closed_at": "={{$json.ticket.closed_at || ''}}",
            "last_ai_at": "={{$json.ticket.last_ai_at || ''}}"
          }
        },
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "GS - Update Customer active_ticket_id",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "update",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "customers",
        "keyColumn": "customer_id",
        "keyValue": "={{$json.customer_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "active_ticket_id": "={{$json.active_ticket_id}}",
            "updated_at": "={{new Date().toISOString()}}"
          }
        },
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "GS - Append Inbound Message",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "append",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "messages",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "message_id": "={{'MSG'+new Date().toISOString().slice(0,10).replaceAll('-','')+String(Math.floor(Math.random()*1e6)).padStart(6,'0')}}",
            "provider_message_id": "={{$json.provider_message_id}}",
            "ticket_id": "={{$json.ticket_id}}",
            "thread_id": "={{$json.thread_id}}",
            "direction": "IN",
            "channel": "={{$json.channel}}",
            "sender": "user",
            "sent_at": "={{$json.sent_at}}",
            "content": "={{$json.content}}",
            "raw_json": "={{$json.raw_json}}",
            "provider": "={{$json.provider}}",
            "provider_event_id": "={{$json.provider_event_id}}",
            "dedupe_key": "={{$json.dedupe_key}}",
            "intent": "",
            "latency_ms": "",
            "ai_json": ""
          }
        },
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "GS - Read Messages (ticket_id)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "read",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "messages",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Build Context (filter last N)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "// Filter messages for this ticket and build last 20 context\nconst all = items.map(i => i.json);\nconst ticket_id = $json.ticket_id;\nconst msg = all.filter(m => m.ticket_id === ticket_id)\n  .sort((a,b)=> Date.parse(a.sent_at||0)-Date.parse(b.sent_at||0))\n  .slice(-20);\nreturn [{json:{...$json, history: msg}}];\n"
      },
      "notes": ""
    },
    {
      "name": "HTTP - RAG Retrieve (Vector DB)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "parameters": {
        "method": "POST",
        "url": "={{$env.VECTOR_URL}}/search",
        "authentication": "<redacted>",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{'Bearer '+$env.VECTOR_API_KEY}}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "jsonBody": "={{ { collection: $env.VECTOR_COLLECTION || 'cdn_kb', query: $json.content, top_k: Number($env.RAG_TOPK||5), filters: { is_active: true } } }}",
        "options": {
          "response": {
            "responseFormat": "json"
          }
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Lookup Products (dynamic facts)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "read",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "products",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Compose Prompt + Guardrails",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "const rag = $json.body || $json; // depending on http node output mapping\nconst ragSnips = (rag.results || rag.hits || []).slice(0, Number($env.RAG_TOPK||5));\nconst products = items.map(i=>i.json); // if connected properly: this node should receive products list\nconst q = ($json.content||'').toLowerCase();\nconst prodHits = products\n  .filter(p => (p.is_active||'').toString().toLowerCase() !== 'false')\n  .filter(p => [p.sku,p.name,p.keywords].some(v => (v||'').toLowerCase().includes(q.split(' ')[0]||'')))\n  .slice(0,5)\n  .map(p => ({sku:p.sku,name:p.name,price:p.price,stock_qty:p.stock_qty}));\n\nconst system = [\n  \"Kamu adalah CS/Sales chatbot. Bahasa Indonesia. Jawab singkat, natural, sopan.\",\n  \"DILARANG mengarang harga/stok. Jika data tidak ada, tanya klarifikasi atau offer handoff.\",\n  \"Output WAJIB JSON valid, tanpa markdown.\",\n  \"Action whitelist: UPDATE_TICKET, CREATE_ORDER_DRAFT, REQUEST_MORE_INFO, HANDOFF, SEND_REPLY, NO_REPLY.\",\n  \"Action dilarang: MARK_PAID, RESTOCK, CHANGE_PRICE, DELETE_DATA.\"\n].join(\"\\n\");\n\nconst context = {\n  ticket_id: $json.ticket_id,\n  thread_id: $json.thread_id,\n  channel: $json.channel,\n  customer_id: $json.customer_id,\n  history: $json.history || [],\n  rag: ragSnips,\n  products: prodHits\n};\n\nconst schema = {\n  should_reply: True,\n  reply_text: \"\",\n  actions: [],\n  handoff: { required: false, reason: \"\" }\n};\n\nreturn [{json:{...$json, llm: {system, context, schema}}}];\n"
      },
      "notes": ""
    },
    {
      "name": "HTTP - LLM Chat (OpenAI compatible)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "parameters": {
        "method": "POST",
        "url": "={{$env.LLM_URL || 'https://api.openai.com/v1/chat/completions'}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{'Bearer '+$env.LLM_API_KEY}}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "jsonBody": "={{ { model: ($env.LLM_MODEL || 'gpt-4o-mini'), temperature: 0.2, messages: [ {role:'system', content:$json.llm.system}, {role:'user', content: JSON.stringify($json.llm.context)} ] } }}",
        "options": {
          "response": {
            "responseFormat": "json"
          }
        }
      },
      "notes": ""
    },
    {
      "name": "Code - Parse & Validate AI Contract",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "const resp = $json;\nconst txt = (resp.choices && resp.choices[0] && resp.choices[0].message && resp.choices[0].message.content) ? resp.choices[0].message.content : JSON.stringify(resp);\nfunction extractJson(s){\n  const m = s.match(/\\{[\\s\\S]*\\}/);\n  return m ? m[0] : null;\n}\nlet obj = null;\ntry { obj = JSON.parse(txt); } catch(e){\n  const ex = extractJson(txt);\n  if (ex) obj = JSON.parse(ex);\n}\nif (!obj) obj = {should_reply:false, reply_text:\"\", actions:[{type:\"HANDOFF\", reason:\"AI output invalid\"}], handoff:{required:true, reason:\"AI output invalid\"}};\n\nconst allowed = new Set([\"UPDATE_TICKET\",\"CREATE_ORDER_DRAFT\",\"REQUEST_MORE_INFO\",\"HANDOFF\",\"SEND_REPLY\",\"NO_REPLY\"]);\nobj.actions = Array.isArray(obj.actions) ? obj.actions.filter(a => a && allowed.has(a.type)) : [];\nif (obj.handoff && obj.handoff.required) {\n  // ok\n} else if (obj.actions.some(a=>a.type===\"HANDOFF\")) {\n  obj.handoff = {required:true, reason:\"handoff_requested\"};\n} else {\n  obj.handoff = {required:false, reason:\"\"};\n}\nreturn [{json:{...$json, ai: obj}}];\n"
      },
      "notes": ""
    },
    {
      "name": "IF - Should Reply?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.ai.should_reply === true}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Append Outbox (PENDING)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "append",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "outbox",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "outbox_id": "={{'OBX'+new Date().toISOString().slice(0,10).replaceAll('-','')+String(Math.floor(Math.random()*1e6)).padStart(6,'0')}}",
            "created_at": "={{new Date().toISOString()}}",
            "updated_at": "={{new Date().toISOString()}}",
            "status": "PENDING",
            "channel": "={{$json.channel}}",
            "provider": "={{$json.provider}}",
            "thread_id": "={{$json.thread_id}}",
            "ticket_id": "={{$json.ticket_id}}",
            "message_id": "",
            "idempotency_key": "",
            "payload_json": "={{JSON.stringify({provider:$json.provider,channel:$json.channel,type:'text',session:$env.WAHA_SESSION,to:$json.thread_id,text:$json.ai.reply_text,meta:{ticket_id:$json.ticket_id,trace_id:$json.trace_id}})}}",
            "response_json": "",
            "last_attempt_at": "",
            "attempt_count": "0",
            "next_retry_at": "={{new Date().toISOString()}}",
            "error_message": ""
          }
        },
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "GS - Release Thread Lock",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "update",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "thread_locks",
        "keyColumn": "thread_id",
        "keyValue": "={{$json.thread_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "locked_until": "={{new Date().toISOString()}}",
            "updated_at": "={{new Date().toISOString()}}"
          }
        },
        "options": {}
      },
      "notes": ""
    }
  ],
  "CDN WF-SEND - Outbox Sender v1": [
    {
      "name": "Cron - Outbox Worker",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Read Outbox",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "read",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "outbox",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Filter Pending/Retry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "const now = Date.now();\nconst rows = items.map(i=>i.json);\nconst eligible = rows.filter(r => {\n  const st = String(r.status||'').toUpperCase();\n  if (!(st === 'PENDING' || st === 'RETRY')) return false;\n  const next = r.next_retry_at ? Date.parse(r.next_retry_at) : 0;\n  return isNaN(next) || next <= now;\n}).slice(0, 10);\nreturn eligible.map(r => ({json:r}));\n"
      },
      "notes": ""
    },
    {
      "name": "Split In Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 2,
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Build Send Idem Key",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "return [{json:{...$json, send_idem_key:`send|${$json.outbox_id}`}}];"
      },
      "notes": ""
    },
    {
      "name": "GS - Lookup Idempotency (send)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "lookup",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "idempotency_keys",
        "lookupColumn": "idem_key",
        "lookupValue": "={{$json.send_idem_key}}"
      },
      "notes": ""
    },
    {
      "name": "IF - Already Sent?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.idem_key !== undefined && $json.status === 'DONE'}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Append Idempotency IN_PROGRESS (send)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "append",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "idempotency_keys",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "idem_key": "={{$json.send_idem_key}}",
            "scope": "send_message",
            "ref_type": "outbox",
            "ref_id": "={{$json.outbox_id}}",
            "status": "IN_PROGRESS",
            "created_at": "={{new Date().toISOString()}}",
            "expires_at": "={{new Date(Date.now()+2*24*3600*1000).toISOString()}}",
            "last_seen_at": "={{new Date().toISOString()}}",
            "result_json": "",
            "error_message": ""
          }
        }
      },
      "notes": ""
    },
    {
      "name": "Switch - Provider",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 2,
      "parameters": {
        "value1": "={{$json.provider}}",
        "rules": [
          {
            "operation": "equal",
            "value2": "WAHA"
          },
          {
            "operation": "equal",
            "value2": "TELEGRAM"
          },
          {
            "operation": "equal",
            "value2": "EMAIL"
          }
        ]
      },
      "notes": ""
    },
    {
      "name": "HTTP - Send WAHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "parameters": {
        "method": "POST",
        "url": "={{$env.WAHA_URL}}/api/sendText",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Api-Key",
              "value": "={{$env.WAHA_API_KEY}}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "jsonBody": "={{ (()=>{ const p = JSON.parse($json.payload_json||'{}'); return { session: p.session || $env.WAHA_SESSION, chatId: p.to, text: p.text }; })() }}",
        "options": {
          "response": {
            "responseFormat": "json"
          }
        }
      },
      "notes": ""
    },
    {
      "name": "Code - Normalize Send Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "const ok = !$json.error && ($json.statusCode === undefined || ($json.statusCode >=200 && $json.statusCode < 300));\n// WAHA typically returns JSON with id or key.id; keep flexible\nconst body = $json.body || $json;\nconst provider_message_id = body.id || (body.key && body.key.id) || body.messageId || '';\nreturn [{json:{...$json, send_ok: ok, provider_message_id, send_raw: JSON.stringify(body), sent_at: new Date().toISOString()}}];\n"
      },
      "notes": ""
    },
    {
      "name": "GS - Append Outbound Message",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "append",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "messages",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "message_id": "={{'MSG'+new Date().toISOString().slice(0,10).replaceAll('-','')+String(Math.floor(Math.random()*1e6)).padStart(6,'0')}}",
            "provider_message_id": "={{$json.provider_message_id}}",
            "ticket_id": "={{$json.ticket_id}}",
            "thread_id": "={{$json.thread_id}}",
            "direction": "OUT",
            "channel": "={{$json.channel}}",
            "sender": "agent",
            "sent_at": "={{$json.sent_at}}",
            "content": "={{ (()=>{ const p=JSON.parse($json.payload_json||'{}'); return p.text||''; })() }}",
            "raw_json": "={{$json.send_raw}}",
            "provider": "={{$json.provider}}",
            "provider_event_id": "",
            "dedupe_key": "={{$json.send_idem_key}}",
            "intent": "",
            "latency_ms": "",
            "ai_json": ""
          }
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Update Ticket After Outbound",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "update",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "tickets",
        "keyColumn": "ticket_id",
        "keyValue": "={{$json.ticket_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "last_outbound_at": "={{new Date().toISOString()}}",
            "unread_flag": "FALSE",
            "updated_at": "={{new Date().toISOString()}}"
          }
        }
      },
      "notes": ""
    },
    {
      "name": "IF - Send OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.send_ok}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Update Outbox DELIVERED",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "update",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "outbox",
        "keyColumn": "outbox_id",
        "keyValue": "={{$json.outbox_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "status": "DELIVERED",
            "response_json": "={{$json.send_raw}}",
            "updated_at": "={{new Date().toISOString()}}",
            "last_attempt_at": "={{new Date().toISOString()}}",
            "attempt_count": "={{String((Number($json.attempt_count||0)+1))}}",
            "error_message": ""
          }
        }
      },
      "notes": ""
    },
    {
      "name": "Code - Backoff + Mark RETRY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "const attempts = Number($json.attempt_count||0)+1;\nconst base = Number($env.OUTBOX_RETRY_BASE_SECONDS || 30);\nconst backoff = Math.min(base * Math.pow(2, attempts-1), 3600);\nreturn [{json:{...$json, attempt_count: attempts, next_retry_at: new Date(Date.now()+backoff*1000).toISOString(), error_message: ($json.error_message||'send_failed')}}];\n"
      },
      "notes": ""
    },
    {
      "name": "GS - Update Outbox RETRY",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "update",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "outbox",
        "keyColumn": "outbox_id",
        "keyValue": "={{$json.outbox_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "status": "RETRY",
            "updated_at": "={{new Date().toISOString()}}",
            "last_attempt_at": "={{new Date().toISOString()}}",
            "attempt_count": "={{String($json.attempt_count)}}",
            "next_retry_at": "={{$json.next_retry_at}}",
            "error_message": "={{$json.error_message}}",
            "response_json": "={{$json.send_raw || ''}}"
          }
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Append Error",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "append",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "errors",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "error_id": "={{'ERR'+new Date().toISOString().slice(0,10).replaceAll('-','')+String(Math.floor(Math.random()*1e6)).padStart(6,'0')}}",
            "occurred_at": "={{new Date().toISOString()}}",
            "workflow_name": "WF-SEND",
            "workflow_id": "={{$workflow.id}}",
            "execution_id": "={{$execution.id}}",
            "node_name": "HTTP - Send WAHA",
            "ticket_id": "={{$json.ticket_id}}",
            "source_message_id": "",
            "trace_id": "",
            "channel": "={{$json.channel}}",
            "direction": "OUT",
            "severity": "error",
            "error_message": "={{$json.error_message}}",
            "error_stack": "",
            "payload_json": "={{$json.payload_json}}",
            "status": "RETRY",
            "last_node": "HTTP - Send WAHA",
            "provider": "={{$json.provider}}",
            "http_status": "",
            "retry_count": "={{String($json.attempt_count||1)}}"
          }
        }
      },
      "notes": ""
    }
  ],
  "CDN WF-KB - Hybrid Knowledge Sync v1": [
    {
      "name": "Cron - KB Sync",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "everyHour"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Read Products",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "read",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "products",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "GS - Read FAQs",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "read",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "faqs",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Build kb_documents",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "// Merge products + faqs into kb_documents rows.\n// Input should be two branches merged manually; for simplicity, keep this node as placeholder.\n// Expected output rows fields: doc_id, source_type, source_id, title, content(rag_text), tags, category, is_active, checksum, index_status, last_indexed_at, metadata_json\nreturn items.map(i => ({json: i.json}));\n"
      },
      "notes": ""
    },
    {
      "name": "GS - Upsert kb_documents",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "appendOrUpdate",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "kb_documents",
        "keyColumn": "doc_id",
        "keyValue": "={{$json.doc_id}}",
        "columns": {
          "mappingMode": "autoMapInputData",
          "value": {}
        }
      },
      "notes": ""
    },
    {
      "name": "Code - Chunking to kb_chunks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "// Chunk content into kb_chunks\nconst doc = $json;\nconst text = doc.content || doc.rag_text || '';\nconst chunkSize = 900;\nconst chunks = [];\nfor (let i=0;i<text.length;i+=chunkSize){\n  chunks.push(text.slice(i, i+chunkSize));\n}\nconst out = chunks.map((c, idx) => ({\n  json: {\n    chunk_id: `CHUNK-${doc.doc_id}-${String(idx+1).padStart(4,'0')}`,\n    doc_id: doc.doc_id,\n    chunk_index: idx+1,\n    chunk_text: c,\n    checksum: \"\",\n    tokens: \"\",\n    created_at: new Date().toISOString(),\n    updated_at: new Date().toISOString(),\n    index_status: \"PENDING\",\n    last_indexed_at: \"\",\n    vector_id: \"\",\n    error_message: \"\",\n    metadata_json: doc.metadata_json || \"\"\n  }\n}));\nreturn out;\n"
      },
      "notes": ""
    },
    {
      "name": "GS - Upsert kb_chunks",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "appendOrUpdate",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "kb_chunks",
        "keyColumn": "chunk_id",
        "keyValue": "={{$json.chunk_id}}",
        "columns": {
          "mappingMode": "autoMapInputData",
          "value": {}
        }
      },
      "notes": ""
    },
    {
      "name": "HTTP - Upsert Vector (placeholder)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "parameters": {
        "method": "POST",
        "url": "={{$env.VECTOR_URL}}/upsert",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{'Bearer '+$env.VECTOR_API_KEY}}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "jsonBody": "={{ { collection: $env.VECTOR_COLLECTION || 'cdn_kb', id: $json.chunk_id, text: $json.chunk_text, metadata: { doc_id: $json.doc_id, chunk_index: $json.chunk_index, is_active: true } } }}",
        "options": {
          "response": {
            "responseFormat": "json"
          }
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Update kb_chunks INDEXED",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "update",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "kb_chunks",
        "keyColumn": "chunk_id",
        "keyValue": "={{$json.chunk_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "index_status": "INDEXED",
            "last_indexed_at": "={{new Date().toISOString()}}",
            "vector_id": "={{($json.body && $json.body.vector_id) || ''}}",
            "updated_at": "={{new Date().toISOString()}}"
          }
        }
      },
      "notes": ""
    }
  ],
  "CDN WF-PAY - Payment Callback v1": [
    {
      "name": "Webhook - Payment Callback v1",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "parameters": {
        "httpMethod": "POST",
        "path": "cdn-wf1-payment-v1",
        "responseMode": "lastNode",
        "options": {}
      },
      "notes": ""
    },
    {
      "name": "Code - Normalize Payment Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "const body = $json.body ?? $json;\nreturn [{json:{\n  provider: body.provider || 'QRIS_GATEWAY',\n  provider_event_id: body.event_id || body.eventId || body.ref || '',\n  order_id: body.order_id || body.orderId || '',\n  amount: body.amount || 0,\n  status: body.status || 'confirmed',\n  paid_at: body.paid_at || new Date().toISOString(),\n  raw_json: JSON.stringify(body)\n}}];\n"
      },
      "notes": ""
    },
    {
      "name": "Code - Build payment idem_key",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "parameters": {
        "jsCode": "return [{json:{...$json, payment_idem_key:`pay|${$json.provider}|${$json.provider_event_id}`}}];"
      },
      "notes": ""
    },
    {
      "name": "GS - Lookup Idempotency (payment)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "lookup",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "idempotency_keys",
        "lookupColumn": "idem_key",
        "lookupValue": "={{$json.payment_idem_key}}"
      },
      "notes": ""
    },
    {
      "name": "IF - Payment Already Processed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.idem_key !== undefined && $json.status === 'DONE'}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Append payments (confirmed)",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "append",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "payments",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "payment_id": "={{'PAY'+new Date().toISOString().slice(0,10).replaceAll('-','')+String(Math.floor(Math.random()*1e6)).padStart(6,'0')}}",
            "order_id": "={{$json.order_id}}",
            "created_at": "={{new Date().toISOString()}}",
            "status": "confirmed",
            "method": "QRIS",
            "amount": "={{$json.amount}}",
            "provider_ref": "={{$json.provider_event_id}}",
            "paid_at": "={{$json.paid_at}}",
            "notes": "",
            "provider": "={{$json.provider}}",
            "provider_event_id": "={{$json.provider_event_id}}",
            "idempotency_key": "={{$json.payment_idem_key}}",
            "confirmed_at": "={{new Date().toISOString()}}",
            "confirmed_by": "system",
            "raw_json": "={{$json.raw_json}}"
          }
        }
      },
      "notes": ""
    },
    {
      "name": "GS - Update order paid",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "parameters": {
        "authentication": "<redacted>",
        "operation": "update",
        "documentId": "={{$env.GSHEET_ID}}",
        "sheetName": "orders",
        "keyColumn": "order_id",
        "keyValue": "={{$json.order_id}}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "payment_status": "paid",
            "status": "paid",
            "updated_at": "={{new Date().toISOString()}}"
          }
        }
      },
      "notes": ""
    },
    {
      "name": "Respond - 200 OK",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "parameters": {
        "responseCode": 200,
        "responseData": "={{ { ok: true } }}"
      },
      "notes": ""
    }
  ]
}